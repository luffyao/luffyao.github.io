[{"author":null,"categories":["Tech"],"content":"linux 内核源码编译，并升级本地 ubuntu 系统","date":1724889600,"description":"linux 内核源码编译，并升级本地 ubuntu 系统","dir":"post/","excerpt_html":"linux 内核源码编译，并升级本地 ubuntu 系统","excerpt_text":"linux 内核源码编译，并升级本地 ubuntu 系统","expirydate":-62135596800,"fuzzywordcount":600,"html":"linux 内核源码编译，并升级本地 ubuntu 系统","keywords":["linux","kernel"],"kind":"page","lang":"en","lastmod":1724889600,"objectID":"ceb4ed834fb7ce25b24ead1744323dd3","permalink":"https://luffyao.github.io/2024/08/make_linux_kernel/","publishdate":"2024-08-29T00:00:00Z","readingtime":2,"relpermalink":"/2024/08/make_linux_kernel/","section":"post","summary":"下载源码 官方网站选择合适版本下载源码 kernel org。 并解压 tar -xvf linux-6.10.6.tar.xz cd linux-6.10.6 安装依赖包 sudo apt-get update sudo apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev 配置内核参数 使用当前系统的默认配置参数： cp /boot/config-$(uname","tags":["linux","kernel"],"title":"手动编译并升级 linux 内核","type":"post","url":"/2024/08/make_linux_kernel/","weight":0,"wordcount":512},{"author":null,"categories":["TECH"],"content":"你以为的负载不均衡，其实是均衡的，只是你不知道而已","date":1683244800,"description":"你以为的负载不均衡，其实是均衡的，只是你不知道而已","dir":"post/","excerpt_html":"你以为的负载不均衡，其实是均衡的，只是你不知道而已","excerpt_text":"你以为的负载不均衡，其实是均衡的，只是你不知道而已","expirydate":-62135596800,"fuzzywordcount":700,"html":"你以为的负载不均衡，其实是均衡的，只是你不知道而已","keywords":["istio","load balancing"],"kind":"page","lang":"en","lastmod":1683244800,"objectID":"993cf04448ce3f7f32a0bc8c5854fcb4","permalink":"https://luffyao.github.io/2023/05/istio_lb/","publishdate":"2023-05-05T00:00:00Z","readingtime":2,"relpermalink":"/2023/05/istio_lb/","section":"post","summary":"问题分析 service 前端有一个 gateway，后端有两个 pod，并且 service 的 DR 中的 LB 的 simple 配置的 round robin，手动用 curl 命令发送请求测试，结果并不是期望的那种","tags":["Istio"],"title":"istio round robin 负载不均衡分析","type":"post","url":"/2023/05/istio_lb/","weight":0,"wordcount":688},{"author":null,"categories":["TECH"],"content":"在稳定性测试下，服务出现 7-8s 的 STW 的情况的分析","date":1651414798,"description":"在稳定性测试下，服务出现 7-8s 的 STW 的情况的分析","dir":"post/","excerpt_html":"在稳定性测试下，服务出现 7-8s 的 STW 的情况的分析","excerpt_text":"在稳定性测试下，服务出现 7-8s 的 STW 的情况的分析","expirydate":-62135596800,"fuzzywordcount":2800,"html":"在稳定性测试下，服务出现 7-8s 的 STW 的情况的分析","keywords":["kafka-go","稳定性测试"],"kind":"page","lang":"en","lastmod":1651414798,"objectID":"7dd5c119c8dd3f42eb5aa1f1b73163e8","permalink":"https://luffyao.github.io/2022/05/kafka-go_analysis/","publishdate":"2022-05-01T22:19:58+08:00","readingtime":6,"relpermalink":"/2022/05/kafka-go_analysis/","section":"post","summary":"问题描述 基于 kafka 框架的两个处理服务的实例，订阅一个 topic，并且有 20 个 partition，在 traffic 正常发送的情况下，手动杀死一个实例，测试是否对","tags":["Kafka"],"title":"基于 kafka-go 的微服务的 Stop the World 分析","type":"post","url":"/2022/05/kafka-go_analysis/","weight":0,"wordcount":2777},{"author":null,"categories":["TECH"],"content":"从源码角度分析 Kubectl 命令删除 Pod 的完整过程","date":1630632023,"description":"从源码角度分析 Kubectl 命令删除 Pod 的完整过程","dir":"post/","excerpt_html":"从源码角度分析 Kubectl 命令删除 Pod 的完整过程","excerpt_text":"从源码角度分析 Kubectl 命令删除 Pod 的完整过程","expirydate":-62135596800,"fuzzywordcount":3200,"html":"从源码角度分析 Kubectl 命令删除 Pod 的完整过程","keywords":["Kubernetes","Docker","Pod"],"kind":"page","lang":"en","lastmod":1630632023,"objectID":"4ea59d8c58c3cdf4d099ce80f189f4ae","permalink":"https://luffyao.github.io/2021/09/what-happened-when-delete-pod/","publishdate":"2021-09-03T09:20:23+08:00","readingtime":7,"relpermalink":"/2021/09/what-happened-when-delete-pod/","section":"post","summary":"前言 当你输入 kubectl delete pods podname 时，K8s 到底是如何将你的 pod 杀死的呢。这篇文章将从源码的角度，带你一起分析这个过程。 分析 当我们调用 Kubectl delete pods 命令的时候，ku","tags":["Kubernetes","Docker"],"title":"记一次 Kubectl 删除 Pod 的过程分析","type":"post","url":"/2021/09/what-happened-when-delete-pod/","weight":0,"wordcount":3122},{"author":null,"categories":["TECH"],"content":"golang 内存优化","date":1629163383,"description":"golang 内存优化","dir":"post/","excerpt_html":"golang 内存优化","excerpt_text":"golang 内存优化","expirydate":-62135596800,"fuzzywordcount":1400,"html":"golang 内存优化","keywords":["golang","profiling","内存优化"],"kind":"page","lang":"en","lastmod":1629163383,"objectID":"7471df4487efbf9cae1a03839901d0e4","permalink":"https://luffyao.github.io/2021/08/golang-memory-optimize/","publishdate":"2021-08-17T09:23:03+08:00","readingtime":3,"relpermalink":"/2021/08/golang-memory-optimize/","section":"post","summary":"前言 最近接到几个关于在压力测试下，pod 中的容器被重启的问题。在查看了下 pod 的信息及使用 dmesg 命令到 node 节点上查看了一下系统日志，发现都是我们的 golang 容","tags":["golang","Profiling"],"title":"Golang 内存优化","type":"post","url":"/2021/08/golang-memory-optimize/","weight":0,"wordcount":1350},{"author":null,"categories":["TECH"],"content":"记录一次系统测试人员测试 Server 端断网，微服务应该回复 500 错误代码给请求端，而不是随机 504，408 错误代码的分析。","date":1622809034,"description":"记录一次系统测试人员测试 Server 端断网，微服务应该回复 500 错误代码给请求端，而不是随机 504，408 错误代码的分析。","dir":"post/","excerpt_html":"记录一次系统测试人员测试 Server 端断网，微服务应该回复 500 错误代码给请求端，而不是随机 504，408 错误代码的分析。","excerpt_text":"记录一次系统测试人员测试 Server 端断网，微服务应该回复 500 错误代码给请求端，而不是随机 504，408 错误代码的分析。","expirydate":-62135596800,"fuzzywordcount":1700,"html":"记录一次系统测试人员测试 Server 端断网，微服务应该回复 500 错误代码给请求端，而不是随机 504，408 错误代码的分析。","keywords":["istio","envoy"],"kind":"page","lang":"en","lastmod":1622809034,"objectID":"f5d21b3a04edb9dfff08d2cf1d38e0df","permalink":"https://luffyao.github.io/2021/06/online_response_408_504_analysis_2/","publishdate":"2021-06-04T20:17:14+08:00","readingtime":4,"relpermalink":"/2021/06/online_response_408_504_analysis_2/","section":"post","summary":"为什么会出现随机 504，408 错误代码？（一） 为什么会出现随机 504，408 错误代码？（二） 问题描述 在第一篇中讲述了这个问题的具体描述，这里","tags":["Istio","envoy"],"title":"为什么会出现随机 504，408 错误代码？（二）","type":"post","url":"/2021/06/online_response_408_504_analysis_2/","weight":0,"wordcount":1633},{"author":null,"categories":["TECH"],"content":"记录一次系统测试人员测试 Server 端断网，微服务应该回复 500 错误代码给请求端，而不是随机 504，408 错误代码的分析。","date":1622702152,"description":"记录一次系统测试人员测试 Server 端断网，微服务应该回复 500 错误代码给请求端，而不是随机 504，408 错误代码的分析。","dir":"post/","excerpt_html":"记录一次系统测试人员测试 Server 端断网，微服务应该回复 500 错误代码给请求端，而不是随机 504，408 错误代码的分析。","excerpt_text":"记录一次系统测试人员测试 Server 端断网，微服务应该回复 500 错误代码给请求端，而不是随机 504，408 错误代码的分析。","expirydate":-62135596800,"fuzzywordcount":3800,"html":"记录一次系统测试人员测试 Server 端断网，微服务应该回复 500 错误代码给请求端，而不是随机 504，408 错误代码的分析。","keywords":["golang","微服务"],"kind":"page","lang":"en","lastmod":1622702152,"objectID":"7372b6c95da3ee36766abe16d133ede1","permalink":"https://luffyao.github.io/2021/06/online_response_408_504_analysis_1/","publishdate":"2021-06-03T14:35:52+08:00","readingtime":8,"relpermalink":"/2021/06/online_response_408_504_analysis_1/","section":"post","summary":"为什么会出现随机 504，408 错误代码？（一） 为什么会出现随机 504，408 错误代码？（二） 问题描述 这是一个我们系统测试人员对我们的微服务请","tags":["golang","net"],"title":"为什么会出现随机 504，408 错误代码？（一）","type":"post","url":"/2021/06/online_response_408_504_analysis_1/","weight":0,"wordcount":3740},{"author":null,"categories":["TECH"],"content":"学习分布式一致性算法 Raft 论文后，个人的理解及总结。","date":1618720817,"description":"学习分布式一致性算法 Raft 论文后，个人的理解及总结。","dir":"post/","excerpt_html":"学习分布式一致性算法 Raft 论文后，个人的理解及总结。","excerpt_text":"学习分布式一致性算法 Raft 论文后，个人的理解及总结。","expirydate":-62135596800,"fuzzywordcount":4100,"html":"学习分布式一致性算法 Raft 论文后，个人的理解及总结。","keywords":["raft","一致性"],"kind":"page","lang":"en","lastmod":1618720817,"objectID":"f40a806418677e9e88990c3b2fe2defd","permalink":"https://luffyao.github.io/2021/04/raft-summary/","publishdate":"2021-04-18T12:40:17+08:00","readingtime":9,"relpermalink":"/2021/04/raft-summary/","section":"post","summary":"前言 最近准备去看看 ETCD 的源码，然后网上看到它是基于 Raft 论文实现的，所以为了后面更好的理解 ETCD，于是便想先来看看 Raft 论文，想先了解下这个分布式数","tags":["raft"],"title":"分布式一致性算法 Raft 论文学习总结","type":"post","url":"/2021/04/raft-summary/","weight":0,"wordcount":4083},{"author":null,"categories":["TECH"],"content":"client-go 中提供的不同种 Informer 的介绍及源码角度对 Informer 机制的分析。","date":1602925535,"description":"client-go 中提供的不同种 Informer 的介绍及源码角度对 Informer 机制的分析。","dir":"post/","excerpt_html":"client-go 中提供的不同种 Informer 的介绍及源码角度对 Informer 机制的分析。","excerpt_text":"client-go 中提供的不同种 Informer 的介绍及源码角度对 Informer 机制的分析。","expirydate":-62135596800,"fuzzywordcount":4200,"html":"client-go 中提供的不同种 Informer 的介绍及源码角度对 Informer 机制的分析。","keywords":["Kubernetes","client-go","informer"],"kind":"page","lang":"en","lastmod":1602925535,"objectID":"759ff72723fb4c061b7116c483fed8e7","permalink":"https://luffyao.github.io/2020/10/clientgoinformer/","publishdate":"2020-10-17T17:05:35+08:00","readingtime":9,"relpermalink":"/2020/10/clientgoinformer/","section":"post","summary":"client-go 源码学习系列： client-go 之概述篇 client-go 之 Informer 篇 client-go 之 WorkQueue 篇 前言 在上篇文章中主要讲解了 client-go 中主要源码目录结构，client-go 提供的各种客户端接口，并且简单介","tags":["Kubernetes","client-go"],"title":"client-go 之 Informer 篇","type":"post","url":"/2020/10/clientgoinformer/","weight":0,"wordcount":4111},{"author":null,"categories":["TECH"],"content":"Golang net/http2 Client 在压力测试下出现 write on closed buffer 错误的分析及解决方法。","date":1601084303,"description":"Golang net/http2 Client 在压力测试下出现 write on closed buffer 错误的分析及解决方法。","dir":"post/","excerpt_html":"Golang net/http2 Client 在压力测试下出现 write on closed buffer 错误的分析及解决方法。","excerpt_text":"Golang net/http2 Client 在压力测试下出现 write on closed buffer 错误的分析及解决方法。","expirydate":-62135596800,"fuzzywordcount":2300,"html":"Golang net/http2 Client 在压力测试下出现 write on closed buffer 错误的分析及解决方法。","keywords":["golang","http2","write an closed buffer"],"kind":"page","lang":"en","lastmod":1601084303,"objectID":"ac134f7c4e2583f40b2324834096a4d4","permalink":"https://luffyao.github.io/2020/09/http2_write_on_closed_buffer_error/","publishdate":"2020-09-26T09:38:23+08:00","readingtime":5,"relpermalink":"/2020/09/http2_write_on_closed_buffer_error/","section":"post","summary":"问题描述 这几天系统测试的同事给我们报了个奇怪的问题，就是在压力测试下，一个服务的 client 端在处理消息的时候会出现 write on closed buffer 的错误。虽然这个问题较为奇","tags":["golang","net"],"title":"write on closed buffer 错误分析","type":"post","url":"/2020/09/http2_write_on_closed_buffer_error/","weight":0,"wordcount":2249},{"author":null,"categories":["TECH"],"content":"这篇内容主要为面向对象设计和编程及 GoF 设计模式在微服务下面的使用","date":1599718343,"description":"这篇内容主要为面向对象设计和编程及 GoF 设计模式在微服务下面的使用","dir":"post/","excerpt_html":"这篇内容主要为面向对象设计和编程及 GoF 设计模式在微服务下面的使用","excerpt_text":"这篇内容主要为面向对象设计和编程及 GoF 设计模式在微服务下面的使用","expirydate":-62135596800,"fuzzywordcount":4200,"html":"这篇内容主要为面向对象设计和编程及 GoF 设计模式在微服务下面的使用","keywords":["设计模式"],"kind":"page","lang":"en","lastmod":1599718343,"objectID":"a8ffdf7ef0e43fae036ffe55c14ff281","permalink":"https://luffyao.github.io/2020/09/designpattern/","publishdate":"2020-09-10T14:12:23+08:00","readingtime":9,"relpermalink":"/2020/09/designpattern/","section":"post","summary":"前言 这篇内容主要为面向对象设计和编程及 GoF 设计模式在微服务下面的使用。因此该篇总结不会讲述 GoF 设计模式的基本内容，只会总结面向对象设计的思想和各","tags":["Design Pattern"],"title":"GoF 23 种设计模式学习总结","type":"post","url":"/2020/09/designpattern/","weight":0,"wordcount":4148},{"author":null,"categories":["TECH"],"content":"client-go 中不同 WorkQueue 的源码分析及默认支持的 Rate Limiter 的介绍","date":1599384295,"description":"client-go 中不同 WorkQueue 的源码分析及默认支持的 Rate Limiter 的介绍","dir":"post/","excerpt_html":"client-go 中不同 WorkQueue 的源码分析及默认支持的 Rate Limiter 的介绍","excerpt_text":"client-go 中不同 WorkQueue 的源码分析及默认支持的 Rate Limiter 的介绍","expirydate":-62135596800,"fuzzywordcount":2900,"html":"client-go 中不同 WorkQueue 的源码分析及默认支持的 Rate Limiter 的介绍","keywords":["Kubernetes","client-go","informer"],"kind":"page","lang":"en","lastmod":1599384295,"objectID":"1bf26d926e54634ceb49cb44631ac5ae","permalink":"https://luffyao.github.io/2020/09/clientgoworkqueue/","publishdate":"2020-09-06T17:24:55+08:00","readingtime":6,"relpermalink":"/2020/09/clientgoworkqueue/","section":"post","summary":"client-go 源码学习系列： client-go 之概述篇 client-go 之 Informer 篇 client-go 之 WorkQueue 篇 前言 在第一篇的概述中，我给大家展示过一张来自官方的 Informer 的处理流程图，在第二篇中，主要和大家介绍并分析","tags":["Kubernetes","client-go"],"title":"client-go 之 WorkQueue 篇","type":"post","url":"/2020/09/clientgoworkqueue/","weight":0,"wordcount":2837},{"author":null,"categories":["TECH"],"content":"简单介绍如何使用 Hugo","date":1599363554,"description":"简单介绍如何使用 Hugo","dir":"post/","excerpt_html":"简单介绍如何使用 Hugo","excerpt_text":"简单介绍如何使用 Hugo","expirydate":-62135596800,"fuzzywordcount":1300,"html":"简单介绍如何使用 Hugo","keywords":["Hexo","Hugo","博客"],"kind":"page","lang":"en","lastmod":1599363554,"objectID":"9d9efe82c200305a656f336d7a2874d1","permalink":"https://luffyao.github.io/2020/09/migratetohugo/","publishdate":"2020-09-06T11:39:14+08:00","readingtime":3,"relpermalink":"/2020/09/migratetohugo/","section":"post","summary":"前言 之前博客是使用 Hexo，但是最近接触了 Hugo， 然后对比了下，感觉 Hugo 性能好很多，然后就学习了下 Hugo，将自己的博客迁移到了 Hugo 上了。这篇","tags":["Hugo"],"title":"将博客从 Hexo 迁移到 Hugo","type":"post","url":"/2020/09/migratetohugo/","weight":0,"wordcount":1219},{"author":null,"categories":["TECH"],"content":"client-go 源码主要目录结构的简单介绍，提供的不同客户端的介绍，Informer 机制的介绍及 WorkQueue 的简单介绍。","date":1596806917,"description":"client-go 源码主要目录结构的简单介绍，提供的不同客户端的介绍，Informer 机制的介绍及 WorkQueue 的简单介绍。","dir":"post/","excerpt_html":"client-go 源码主要目录结构的简单介绍，提供的不同客户端的介绍，Informer 机制的介绍及 WorkQueue 的简单介绍。","excerpt_text":"client-go 源码主要目录结构的简单介绍，提供的不同客户端的介绍，Informer 机制的介绍及 WorkQueue 的简单介绍。","expirydate":-62135596800,"fuzzywordcount":2800,"html":"client-go 源码主要目录结构的简单介绍，提供的不同客户端的介绍，Informer 机制的介绍及 WorkQueue 的简单介绍。","keywords":["Kubernetes","client-go","informer"],"kind":"page","lang":"en","lastmod":1596806917,"objectID":"56279a6a0d10cc6fd73c5b3917ae06ef","permalink":"https://luffyao.github.io/2020/08/clientgooverall/","publishdate":"2020-08-07T21:28:37+08:00","readingtime":6,"relpermalink":"/2020/08/clientgooverall/","section":"post","summary":"client-go 源码学习系列： client-go 之概述篇 client-go 之 Informer 篇 client-go 之 WorkQueue 篇 前言 目前在云原生社区的 Kubernetes 源码研习社中和广大学友们共同学习郑东旭大佬的 kubernetes 源码剖析 这本书。当前正在开展","tags":["Kubernetes","client-go"],"title":"client-go 之概述篇","type":"post","url":"/2020/08/clientgooverall/","weight":0,"wordcount":2775},{"author":null,"categories":["TECH"],"content":"一步步教你如何在 ubuntu 上安装 K8s","date":1595662602,"description":"一步步教你如何在 ubuntu 上安装 K8s","dir":"post/","excerpt_html":"一步步教你如何在 ubuntu 上安装 K8s","excerpt_text":"一步步教你如何在 ubuntu 上安装 K8s","expirydate":-62135596800,"fuzzywordcount":1800,"html":"一步步教你如何在 ubuntu 上安装 K8s","keywords":["Ubuntu","Kubernetes"],"kind":"page","lang":"en","lastmod":1595662602,"objectID":"c7bcc599a6b65ccafc01e2be84cd13db","permalink":"https://luffyao.github.io/2020/07/vminstallk8s/","publishdate":"2020-07-25T15:36:42+08:00","readingtime":4,"relpermalink":"/2020/07/vminstallk8s/","section":"post","summary":"安装步骤 安装虚拟机 安装至少需要安装两个 ubuntu 虚拟机，根据个人需求，和电脑配置，这里我是两个虚拟机，一个 master ，一个 node 。每个虚拟机 2 CPU，4G 内存。","tags":["Kubernetes"],"title":"本地 ubuntu18.04 VM 安装 k8s","type":"post","url":"/2020/07/vminstallk8s/","weight":0,"wordcount":1749},{"author":null,"categories":["TECH"],"content":"如何使用 controller-runtime 实现一个简单的准入 webhook。","date":1589691842,"description":"如何使用 controller-runtime 实现一个简单的准入 webhook。","dir":"post/","excerpt_html":"如何使用 controller-runtime 实现一个简单的准入 webhook。","excerpt_text":"如何使用 controller-runtime 实现一个简单的准入 webhook。","expirydate":-62135596800,"fuzzywordcount":800,"html":"如何使用 controller-runtime 实现一个简单的准入 webhook。","keywords":null,"kind":"page","lang":"en","lastmod":1589691842,"objectID":"756da045751997016f217facb7cf3248","permalink":"https://luffyao.github.io/2020/05/admission-controller-webhook/","publishdate":"2020-05-17T13:04:02+08:00","readingtime":2,"relpermalink":"/2020/05/admission-controller-webhook/","section":"post","summary":"前言 上一篇 client-go 实现准入 webhook 讲的是直接用 client-go 去编写 webhook server. 这篇将讲述如何使用 controller-runtime 快速的写一个 webhook server. 编写 webhook server 这次是直接用 controller-runtime 的 webhook, 自己写一个 handle 处理逻辑就好了，所以","tags":["Kubernetes"],"title":"controller-runtime 实现准入 webhook","type":"post","url":"/2020/05/admission-controller-webhook/","weight":0,"wordcount":702},{"author":null,"categories":["TECH"],"content":"client-go 实现一个简单的准入 webhook。","date":1589352155,"description":"client-go 实现一个简单的准入 webhook。","dir":"post/","excerpt_html":"client-go 实现一个简单的准入 webhook。","excerpt_text":"client-go 实现一个简单的准入 webhook。","expirydate":-62135596800,"fuzzywordcount":1200,"html":"client-go 实现一个简单的准入 webhook。","keywords":["Kubernetes","client-go","webhook"],"kind":"page","lang":"en","lastmod":1589352155,"objectID":"12b9b7f1f3f25e4544104f6e4b1deb04","permalink":"https://luffyao.github.io/2020/05/k8s-webhook-admission-control/","publishdate":"2020-05-13T14:42:35+08:00","readingtime":3,"relpermalink":"/2020/05/k8s-webhook-admission-control/","section":"post","summary":"什么是准入 webhook 准入 webhooks 是一个接收 admission 请求并对其做些处理的 HTTP 回调。你可以定义两种准入 webhook,validating admission webhook and mutating admission webhook。mutating admission webhook 首先被调用，然后","tags":["Kubernetes"],"title":"client-go 实现准入 webhook","type":"post","url":"/2020/05/k8s-webhook-admission-control/","weight":0,"wordcount":1143},{"author":null,"categories":["TECH"],"content":"简单介绍 HTTP2.0 中的头部压缩算法 HPACK。","date":1586087602,"description":"简单介绍 HTTP2.0 中的头部压缩算法 HPACK。","dir":"post/","excerpt_html":"简单介绍 HTTP2.0 中的头部压缩算法 HPACK。","excerpt_text":"简单介绍 HTTP2.0 中的头部压缩算法 HPACK。","expirydate":-62135596800,"fuzzywordcount":2200,"html":"简单介绍 HTTP2.0 中的头部压缩算法 HPACK。","keywords":["HPACK","头部压缩"],"kind":"page","lang":"en","lastmod":1586087602,"objectID":"2f08a2ea017405a1fddf064ef29a2ca5","permalink":"https://luffyao.github.io/2020/04/hpack-summary/","publishdate":"2020-04-05T19:53:22+08:00","readingtime":5,"relpermalink":"/2020/04/hpack-summary/","section":"post","summary":"概括 HPACK 是一个新的可以消除 header 字段冗余，限制已知安全攻击的脆弱性和在受限的环境中有限的内存使用的压缩器。RFC7541 定义了两个表，分别是一张静","tags":["HPACK"],"title":"RFC7541 HPACK 总结","type":"post","url":"/2020/04/hpack-summary/","weight":0,"wordcount":2128},{"author":null,"categories":["TECH"],"content":"如何使用 operator-sdk 生成一个CRD。","date":1585789871,"description":"如何使用 operator-sdk 生成一个CRD。","dir":"post/","excerpt_html":"如何使用 operator-sdk 生成一个CRD。","excerpt_text":"如何使用 operator-sdk 生成一个CRD。","expirydate":-62135596800,"fuzzywordcount":600,"html":"如何使用 operator-sdk 生成一个CRD。","keywords":["Kubernetes","Operator-sdk","CRD"],"kind":"page","lang":"en","lastmod":1585789871,"objectID":"45bae9d6585d6f7af37c0378817bb497","permalink":"https://luffyao.github.io/2020/04/using-operator-sdk-to-generate-k8s-crd/","publishdate":"2020-04-02T09:11:11+08:00","readingtime":2,"relpermalink":"/2020/04/using-operator-sdk-to-generate-k8s-crd/","section":"post","summary":"What is CRD The CustomResourceDefinition API resource allows you to define custom resources. Defining a CRD object creates a new custom resource with a name and schema that you specify. The Kubernetes API serves and handles the storage of your custom resource. The name of a CRD object must be a valid DNS subdomain name. more detailed info please refer to CRD definition What is operator-sdk The SDK provides the","tags":["Kubernetes","Operator-sdk"],"title":"使用 operator-sdk 生成一个CRD","type":"post","url":"/2020/04/using-operator-sdk-to-generate-k8s-crd/","weight":0,"wordcount":519},{"author":null,"categories":["TECH"],"content":"如何在 pod 中做 golang 的 profiling。","date":1583556822,"description":"如何在 pod 中做 golang 的 profiling。","dir":"post/","excerpt_html":"如何在 pod 中做 golang 的 profiling。","excerpt_text":"如何在 pod 中做 golang 的 profiling。","expirydate":-62135596800,"fuzzywordcount":500,"html":"如何在 pod 中做 golang 的 profiling。","keywords":["Profiling","golang"],"kind":"page","lang":"en","lastmod":1583556822,"objectID":"8e587639cffbc10669cd351a957885ef","permalink":"https://luffyao.github.io/2020/03/how_to_profiling_go_in_pod/","publishdate":"2020-03-07T12:53:42+08:00","readingtime":1,"relpermalink":"/2020/03/how_to_profiling_go_in_pod/","section":"post","summary":"前言 相比于 C++ 在 pod 中做 profiling， 那么对于云原生的 golang 来说就太方便了。下面我将讲述下我做 golang profiling 的具体过程和步骤。由于我们是基于 Restful 接口的系统","tags":["Docker","Profiling"],"title":"如何在 pod 中做 golang 的 profiling","type":"post","url":"/2020/03/how_to_profiling_go_in_pod/","weight":0,"wordcount":499},{"author":null,"categories":["TECH"],"content":null,"date":1578646263,"description":"","dir":"post/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1400,"html":null,"keywords":["istio","mtls"],"kind":"page","lang":"en","lastmod":1578646263,"objectID":"a1ff097cc6b37d2150fa97f4ace3ed2d","permalink":"https://luffyao.github.io/2020/01/config_mtls_in_istio/","publishdate":"2020-01-10T16:51:03+08:00","readingtime":3,"relpermalink":"/2020/01/config_mtls_in_istio/","section":"post","summary":"ISTIO MTLS SUMMARY THIS IS BASED ON ISTIO OFFICIAL PACKAGE ISTIO-1.3.5(FOLLOWING ALL OF ISTIO DOCS MUST OVER THE WALL,YOU CAN REFERENCE THE LATEST VERDION DOCS), BECAUSE OUR ENV VERSION IS BASED ON THIS VERSION. Test Flow TODO Update MeshPolicy from PERMISSIVE to STRICT NOTE: More infor about this in our ENV, please look at following Question section Q2 Reference link MutlalTls-Mode kubectl get meshpolicy kubectl edit meshpolicy ///// then manually","tags":["Istio","mTLS"],"title":"istio 配置 mtls","type":"post","url":"/2020/01/config_mtls_in_istio/","weight":0,"wordcount":1389},{"author":null,"categories":["TECH"],"content":"整理下 iptables 的工作原理","date":1577236241,"description":"整理下 iptables 的工作原理","dir":"post/","excerpt_html":"整理下 iptables 的工作原理","excerpt_text":"整理下 iptables 的工作原理","expirydate":-62135596800,"fuzzywordcount":1800,"html":"整理下 iptables 的工作原理","keywords":["Iptables"],"kind":"page","lang":"en","lastmod":1577236241,"objectID":"8a6e33076bbdc688c3dfdeb4446acccc","permalink":"https://luffyao.github.io/2019/12/understanding_of_iptables/","publishdate":"2019-12-25T09:10:41+08:00","readingtime":4,"relpermalink":"/2019/12/understanding_of_iptables/","section":"post","summary":"前言 今天刚好放假，有空来整理下 iptables 的工作原理。对于 iptables/netfilter 的接触，还是之前研究 k8s service load balancing 时深入学习了下工作原理。 概念理解 下面摘录下官方的定义： netfilter is a set","tags":["Iptables","Netfilter"],"title":"深入理解 iptables 工作原理","type":"post","url":"/2019/12/understanding_of_iptables/","weight":0,"wordcount":1760},{"author":null,"categories":null,"content":null,"date":1576915651,"description":"","dir":"top/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1576915651,"objectID":"7a0da914bde98a7d3fcc7f6c5886633c","permalink":"https://luffyao.github.io/top/about/","publishdate":"2019-12-21T16:07:31+08:00","readingtime":1,"relpermalink":"/top/about/","section":"top","summary":"熟悉C++/golang 开发，云原生技术爱好者，熟悉微服务开发，目前 Kubernetes 源码学习中。自认为是勤劳的小码农一枚，职业处在起步期，希望大佬们多多支","tags":null,"title":"个人简介","type":"about","url":"/top/about/","weight":0,"wordcount":74},{"author":null,"categories":["TECH"],"content":"如何在提交代码的时候自动自动添加 reviewers。","date":1576850556,"description":"如何在提交代码的时候自动自动添加 reviewers。","dir":"post/","excerpt_html":"如何在提交代码的时候自动自动添加 reviewers。","excerpt_text":"如何在提交代码的时候自动自动添加 reviewers。","expirydate":-62135596800,"fuzzywordcount":700,"html":"如何在提交代码的时候自动自动添加 reviewers。","keywords":["gerrit"],"kind":"page","lang":"en","lastmod":1576850556,"objectID":"d0033706d62e1d9c7fdf20db53000c2c","permalink":"https://luffyao.github.io/2019/12/auto_add_reviewers_in_gerrit/","publishdate":"2019-12-20T22:02:36+08:00","readingtime":2,"relpermalink":"/2019/12/auto_add_reviewers_in_gerrit/","section":"post","summary":"前言 我想用过 gerrit 的同学都知道，这个真的是个神 code review 工具，可以 verify, view, 还可以 cherry-pick 等等功能。这里我不做过多解释。有需要的可以自行百度了解基本知识。 但是就是","tags":["Gerrit"],"title":"gerrit 自动添加 reviewers","type":"post","url":"/2019/12/auto_add_reviewers_in_gerrit/","weight":0,"wordcount":658},{"author":null,"categories":["日常随笔"],"content":"CSDN 尽然拒绝了我这篇文章的发表!!!","date":1576300925,"description":"CSDN 尽然拒绝了我这篇文章的发表!!!","dir":"post/","excerpt_html":"CSDN 尽然拒绝了我这篇文章的发表!!!","excerpt_text":"CSDN 尽然拒绝了我这篇文章的发表!!!","expirydate":-62135596800,"fuzzywordcount":2300,"html":"CSDN 尽然拒绝了我这篇文章的发表!!!","keywords":["CSDN"],"kind":"page","lang":"en","lastmod":1576300925,"objectID":"e6b4b0924c92c21a8871fb53c34ce97a","permalink":"https://luffyao.github.io/2019/12/personal_thinking_of_csdn/","publishdate":"2019-12-14T13:22:05+08:00","readingtime":5,"relpermalink":"/2019/12/personal_thinking_of_csdn/","section":"post","summary":"CSDN 尽然拒绝了我这篇文章的发表！！！ Are you kidding me? 谈谈我对 CSDN 的个人感受 不知不觉已经在 CSDN 有 6 个年头了，多多少少也写了不少 blog 了。但是我想这应该是我最后一","tags":["随笔"],"title":"谈谈我对 CSDN 的个人感受","type":"post","url":"/2019/12/personal_thinking_of_csdn/","weight":0,"wordcount":2293},{"author":null,"categories":["TECH"],"content":"C++ 17 中的 the overload pattern 简单介绍。","date":1575773398,"description":"C++ 17 中的 the overload pattern 简单介绍。","dir":"post/","excerpt_html":"C++ 17 中的 the overload pattern 简单介绍。","excerpt_text":"C++ 17 中的 the overload pattern 简单介绍。","expirydate":-62135596800,"fuzzywordcount":400,"html":"C++ 17 中的 the overload pattern 简单介绍。","keywords":["C++17","overload pattern"],"kind":"page","lang":"en","lastmod":1575773398,"objectID":"8afcb2d4ef0756e386e446bdcdd920dd","permalink":"https://luffyao.github.io/2019/12/overload_pattern_in_cplusplus17/","publishdate":"2019-12-08T10:49:58+08:00","readingtime":1,"relpermalink":"/2019/12/overload_pattern_in_cplusplus17/","section":"post","summary":"简单介绍 以前在 C++98 的时候，咱们想要操作符重载怎么办？我们一般都是会将想要重载的操作符在自己的 class 或者 struct 里面写一遍。 一般大家写出来的代码无非和我的","tags":["C++17"],"title":"C++ 17 尝鲜之 the overload pattern","type":"post","url":"/2019/12/overload_pattern_in_cplusplus17/","weight":0,"wordcount":312},{"author":null,"categories":["TECH"],"content":"C++ 17 中的 structured bindings 简单介绍。","date":1575773052,"description":"C++ 17 中的 structured bindings 简单介绍。","dir":"post/","excerpt_html":"C++ 17 中的 structured bindings 简单介绍。","excerpt_text":"C++ 17 中的 structured bindings 简单介绍。","expirydate":-62135596800,"fuzzywordcount":300,"html":"C++ 17 中的 structured bindings 简单介绍。","keywords":["C++17","结构绑定"],"kind":"page","lang":"en","lastmod":1575773052,"objectID":"536a83c8d0de801d90cb889f9e789055","permalink":"https://luffyao.github.io/2019/12/structured_bindings_in_cplusplus17/","publishdate":"2019-12-08T10:44:12+08:00","readingtime":1,"relpermalink":"/2019/12/structured_bindings_in_cplusplus17/","section":"post","summary":"简单介绍 老版本的 C++函数返回值都是只有一个内嵌类型或者自定义类型。所以 以前 我们如果想要返回多个值，就必须将其封装为 struct， 然后在将其","tags":["C++17"],"title":"C++17 尝鲜之 structured bindings","type":"post","url":"/2019/12/structured_bindings_in_cplusplus17/","weight":0,"wordcount":220},{"author":null,"categories":["TECH"],"content":"简易抓取 container 中的 tcpdump","date":1575715489,"description":"简易抓取 container 中的 tcpdump","dir":"post/","excerpt_html":"简易抓取 container 中的 tcpdump","excerpt_text":"简易抓取 container 中的 tcpdump","expirydate":-62135596800,"fuzzywordcount":700,"html":"简易抓取 container 中的 tcpdump","keywords":["tcpdump","docker","container"],"kind":"page","lang":"en","lastmod":1575715489,"objectID":"d478bd23245eee75ad5e97cc1190802e","permalink":"https://luffyao.github.io/2019/12/how_to_grab_tcpdump_in_container/","publishdate":"2019-12-07T18:44:49+08:00","readingtime":2,"relpermalink":"/2019/12/how_to_grab_tcpdump_in_container/","section":"post","summary":"前言 一般情况下，想要抓取 pod 中的某个 container 的 tcpdump，直接 kubectl exec 进入那个 container，然后就可以抓取了。但是如果当你的 image 没有安装 bash 等 shell t","tags":["Docker","Tcpdump"],"title":"如何抓取 pod 中的 container 的 Tcpdump","type":"post","url":"/2019/12/how_to_grab_tcpdump_in_container/","weight":0,"wordcount":688},{"author":null,"categories":["TECH"],"content":"简单介绍如何在 container 里面生成 coredump 文件并拷贝出来，然后使用 GDB 去 debug。","date":1575293701,"description":"简单介绍如何在 container 里面生成 coredump 文件并拷贝出来，然后使用 GDB 去 debug。","dir":"post/","excerpt_html":"简单介绍如何在 container 里面生成 coredump 文件并拷贝出来，然后使用 GDB 去 debug。","excerpt_text":"简单介绍如何在 container 里面生成 coredump 文件并拷贝出来，然后使用 GDB 去 debug。","expirydate":-62135596800,"fuzzywordcount":800,"html":"简单介绍如何在 container 里面生成 coredump 文件并拷贝出来，然后使用 GDB 去 debug。","keywords":["coredump","container","GDB"],"kind":"page","lang":"en","lastmod":1575293701,"objectID":"32384257d69e8d1f2a4fa279d722224a","permalink":"https://luffyao.github.io/2019/12/how-_to_copy_coredump_in_the_container/","publishdate":"2019-12-02T21:35:01+08:00","readingtime":2,"relpermalink":"/2019/12/how-_to_copy_coredump_in_the_container/","section":"post","summary":"前言 为什么会记录这篇文章呢，是因为在工作中，遇到了这个问题，由于我们这个是 C++写的代码，crash tracing 并没有 golang 好，所以代码 crash 在 pod 中的 container 里面，","tags":["Docker","Coredump"],"title":"如何在 pod 中的 container 里面生成 coredump 文件并拷贝出来使用 GDB debug","type":"post","url":"/2019/12/how-_to_copy_coredump_in_the_container/","weight":0,"wordcount":759},{"author":null,"categories":["TECH"],"content":"如何用 Linux 系统自带的 Perf 给 C++代码做性能分析。","date":1575203571,"description":"如何用 Linux 系统自带的 Perf 给 C++代码做性能分析。","dir":"post/","excerpt_html":"如何用 Linux 系统自带的 Perf 给 C++代码做性能分析。","excerpt_text":"如何用 Linux 系统自带的 Perf 给 C++代码做性能分析。","expirydate":-62135596800,"fuzzywordcount":300,"html":"如何用 Linux 系统自带的 Perf 给 C++代码做性能分析。","keywords":["Profiling","Perf","C++","性能分析"],"kind":"page","lang":"en","lastmod":1575203571,"objectID":"96c2f3875ae25a07615c131ee3b7f0e4","permalink":"https://luffyao.github.io/2019/12/profiling-c-with-perf-in-the-linux-env/","publishdate":"2019-12-01T20:32:51+08:00","readingtime":1,"relpermalink":"/2019/12/profiling-c-with-perf-in-the-linux-env/","section":"post","summary":"前言 该篇主要是记录如何使用 Linux 自带的 Pref 工具看 C++程序的性能问题。该篇只是简单的记录如何收集性能数据，具体分析这里不做描述。 安装 perf sudo apt-get install linux-tools-common sudo apt-get","tags":["Profiling"],"title":"用 Perf 给 C++ 代码做 Profiling","type":"post","url":"/2019/12/profiling-c-with-perf-in-the-linux-env/","weight":0,"wordcount":291},{"author":null,"categories":["TECH"],"content":null,"date":1575200355,"description":"","dir":"post/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":200,"html":null,"keywords":["Docker","Ubuntu"],"kind":"page","lang":"en","lastmod":1575200355,"objectID":"4a9282f045f3a46d084ce18e98ce513a","permalink":"https://luffyao.github.io/2019/12/how-to-install-docker-ce-in-the-ubuntu-18-04/","publishdate":"2019-12-01T19:39:15+08:00","readingtime":1,"relpermalink":"/2019/12/how-to-install-docker-ce-in-the-ubuntu-18-04/","section":"post","summary":"安装 官方网站上选择一个合适的安装方法。请参考 官方文档。 注意 Maybe you will appear docker-ce-cli not found issue,when using following command which written by docker formal docs to install docker ce. you can refernce my solution to solve it. 使用 Docker 官方文档编写的以下","tags":["Docker"],"title":"Ubuntu 18.04 上安装 Docker CE","type":"post","url":"/2019/12/how-to-install-docker-ce-in-the-ubuntu-18-04/","weight":0,"wordcount":181},{"author":null,"categories":["TECH"],"content":null,"date":1575185955,"description":"","dir":"post/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":300,"html":null,"keywords":["github","git"],"kind":"page","lang":"en","lastmod":1575185955,"objectID":"4576c6c1fd1b763c840f320b3443592d","permalink":"https://luffyao.github.io/2019/12/update_forked_repo_from_original_repo_in_github/","publishdate":"2019-12-01T15:39:15+08:00","readingtime":1,"relpermalink":"/2019/12/update_forked_repo_from_original_repo_in_github/","section":"post","summary":"前言 在 github 上 一般我们都是将别人的 repo fork 到自己的 github repo。 然后阅读，修改 甚至是 contribution。所以同步源 repo 的 commit 尤为重要。因为你要始终保","tags":["github","git"],"title":"github 上将源 repo 提交更新到 fork 的 repo","type":"post","url":"/2019/12/update_forked_repo_from_original_repo_in_github/","weight":0,"wordcount":280},{"author":null,"categories":null,"content":null,"date":-62135596800,"description":"","dir":"search/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8946788897930c0c0c39fbfcd30ff2e4","permalink":"https://luffyao.github.io/search/placeholder/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/search/placeholder/","section":"search","summary":"","tags":null,"title":"","type":"search","url":"/search/placeholder/","weight":0,"wordcount":0}]